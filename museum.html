<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ› Virtual Museum</title>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       Three.js r160 + PointerLockControls (CDN importmap)
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; font-family: 'Georgia', 'Hiragino Mincho ProN', serif; }
    canvas { display: block; }

    /* â”€â”€ ã‚¹ã‚¿ãƒ¼ãƒˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆãƒ©ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒšãƒ¼ã‚¸ï¼‰ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #overlay {
      position: fixed; inset: 0;
      background: rgba(10, 8, 6, 0.93);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      gap: 0;
      z-index: 20;
      transition: opacity 0.7s ease;
      overflow-y: auto;
      padding: 40px 20px;
    }
    #overlay.hidden { opacity: 0; pointer-events: none; }
    #overlay h1 {
      color: #f0e8d4;
      font-size: clamp(2rem, 5vw, 3.4rem);
      letter-spacing: 0.45em;
      text-shadow: 0 0 50px rgba(255, 210, 130, 0.40);
      margin-bottom: 6px;
    }
    #overlay .subtitle {
      color: #7a6e60; font-size: 0.82rem; letter-spacing: 0.22em;
      margin-bottom: 32px;
    }

    /* â”€â”€ ã‚µãƒ¼ãƒ“ã‚¹èª¬æ˜ã‚¨ãƒªã‚¢ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #serviceDesc {
      max-width: 440px; width: 100%; text-align: center;
      border-top: 1px solid rgba(240, 220, 170, 0.16);
      border-bottom: 1px solid rgba(240, 220, 170, 0.16);
      padding: 26px 16px;
      margin-bottom: 28px;
    }
    #overlay .description {
      color: #c4b89e;
      font-size: clamp(0.88rem, 2vw, 1.0rem);
      line-height: 2.1;
      letter-spacing: 0.06em;
      margin-bottom: 20px;
    }
    .price-badge {
      display: inline-block;
      color: #f8edce;
      font-size: 1.35rem;
      letter-spacing: 0.18em;
      background: rgba(200, 160, 80, 0.14);
      border: 1px solid rgba(200, 160, 80, 0.38);
      border-radius: 3px;
      padding: 7px 24px;
      margin-bottom: 14px;
    }
    .payment-methods {
      color: #6a5e50;
      font-size: 0.78rem;
      letter-spacing: 0.1em;
    }

    /* â”€â”€ æ”¯æ‰•ã„æ¸ˆã¿ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #paidMsg {
      color: #88c06a;
      font-size: 0.88rem;
      letter-spacing: 0.14em;
      margin-bottom: 20px;
      display: none;
    }

    /* â”€â”€ å…¥å ´ãƒœã‚¿ãƒ³ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #startBtn {
      padding: 14px 52px;
      background: transparent;
      border: 1px solid rgba(240, 220, 170, 0.48);
      color: #f0e8d4;
      font-size: 1.05rem; letter-spacing: 0.28em;
      cursor: pointer; border-radius: 2px;
      transition: background 0.25s, border-color 0.25s;
      font-family: inherit;
      margin-bottom: 18px;
    }
    #startBtn:hover {
      background: rgba(255, 240, 200, 0.11);
      border-color: rgba(240, 220, 170, 0.85);
    }
    #overlay .keyhint {
      color: #504840; font-size: 0.76rem;
      letter-spacing: 0.08em; line-height: 1.9;
      text-align: center;
      display: none;
    }

    /* â”€â”€ ã‚¯ãƒ­ã‚¹ãƒ˜ã‚¢ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #crosshair {
      position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 22px; height: 22px;
      pointer-events: none; z-index: 10;
      display: none;
    }
    #crosshair.show { display: block; }
    #crosshair::before {
      content: ''; position: absolute;
      width: 2px; height: 22px;
      background: rgba(255, 255, 255, 0.65);
      left: 10px; top: 0;
    }
    #crosshair::after {
      content: ''; position: absolute;
      width: 22px; height: 2px;
      background: rgba(255, 255, 255, 0.65);
      top: 10px; left: 0;
    }

    /* â”€â”€ æ“ä½œãƒ’ãƒ³ãƒˆ (å³ä¸‹) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #hint {
      position: fixed; bottom: 20px; right: 22px;
      color: rgba(255, 255, 255, 0.38);
      font-size: 0.72rem; line-height: 2.0;
      letter-spacing: 0.06em; text-align: right;
      pointer-events: none; z-index: 10;
      font-family: 'Courier New', monospace;
      display: none;
    }
    #hint.show { display: block; }

    /* â”€â”€ ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤º â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #loading {
      position: fixed; bottom: 22px; left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.45);
      font-size: 0.8rem; letter-spacing: 0.12em;
      pointer-events: none; z-index: 20;
      font-family: sans-serif;
    }

    /* â”€â”€ ESC ä¸­æ–­ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #pauseMsg {
      position: fixed; top: 22px; left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.5);
      font-size: 0.8rem; letter-spacing: 0.1em;
      pointer-events: none; z-index: 10;
      display: none; font-family: sans-serif;
    }
    #pauseMsg.show { display: block; }
  </style>
</head>
<body>

<!-- â”€â”€â”€ UI ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="overlay">
  <h1>ğŸ›ã€€ç¾ è¡“ é¤¨</h1>
  <p class="subtitle">VIRTUAL MUSEUM</p>

  <!-- â”€â”€ ã‚µãƒ¼ãƒ“ã‚¹èª¬æ˜ï¼ˆæœªæ‰•ã„æ™‚ã«è¡¨ç¤ºï¼‰ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div id="serviceDesc">
    <p class="description">
      å®¶ã«ã„ãªãŒã‚‰ç¾è¡“é¤¨ã«è¡Œã‘ã‚‹ã‚µãƒ¼ãƒ“ã‚¹ã§ã™ã€‚<br>
      ã‚†ã£ãã‚Šçµµã‚’è¦‹ã‚‹æ™‚é–“ã¯ã€æ™®æ®µãªã‹ãªã‹å–ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚<br>
      éæ—¥å¸¸ã®ç‰¹åˆ¥ãªä½“é¨“ã‚’æä¾›ã—ã¾ã™ã€‚
    </p>
    <div class="price-badge">å…¥ å ´ æ–™ &emsp; Â¥500</div><br>
    <p class="payment-methods">
      ğŸ’³ ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆã‚«ãƒ¼ãƒ‰ &ensp;ï¼&ensp; ğŸ“± ã‚³ãƒ¼ãƒ‰æ±ºæ¸ˆ
    </p>
  </div>

  <!-- â”€â”€ æ”¯æ‰•ã„å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆæ”¯æ‰•ã„æ¸ˆã¿æ™‚ã«è¡¨ç¤ºï¼‰ â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <p id="paidMsg">âœ“ ãŠæ”¯æ‰•ã„ãŒå®Œäº†ã—ã¾ã—ãŸ</p>

  <!-- â”€â”€ ãƒœã‚¿ãƒ³ï¼ˆæœªæ‰•ã„ï¼šæ±ºæ¸ˆã¸ ï¼ æ”¯æ‰•æ¸ˆã¿ï¼šå…¥å ´ï¼‰ â”€â”€â”€â”€â”€â”€â”€ -->
  <button id="startBtn">å…¥å ´ã™ã‚‹ &emsp; Â¥500</button>

  <!-- â”€â”€ æ“ä½œèª¬æ˜ï¼ˆæ”¯æ‰•ã„æ¸ˆã¿æ™‚ã«è¡¨ç¤ºï¼‰ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <p class="keyhint" id="keyhint">
    W / A / S / D ï¼šç§»å‹•ã€€ã€€ãƒã‚¦ã‚¹ï¼šè¦–ç‚¹å›è»¢<br>
    Shiftï¼šèµ°ã‚‹ã€€ã€€ESCï¼šä¸€æ™‚åœæ­¢
  </p>
</div>

<div id="crosshair"></div>
<div id="hint">
  W A S D ï¼šç§»å‹•<br>
  ãƒã‚¦ã‚¹ï¼šè¦–ç‚¹å›è»¢<br>
  Shift ï¼šèµ°ã‚‹<br>
  ESC ï¼šä¸€æ™‚åœæ­¢
</div>
<div id="loading">çµµç”»ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...</div>
<div id="pauseMsg">ä¸€æ™‚åœæ­¢ä¸­ â”€â”€ ã‚¯ãƒªãƒƒã‚¯ã§å†é–‹</div>

<!-- â”€â”€â”€ ãƒ¡ã‚¤ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

/*
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *  ğŸ› THREE.js ç¾è¡“é¤¨  â”€  5ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆçµ±åˆç‰ˆ
 *
 *  ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæ§‹æˆ:
 *   Agent 1: å»ºç¯‰ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ  â”€ éƒ¨å±‹ãƒ»å£ãƒ»æŸ±ãƒ»ã‚¢ãƒ¼ãƒ
 *   Agent 2: ç…§æ˜ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ  â”€ å¤ªé™½å…‰ãƒ»ã‚¹ãƒãƒƒãƒˆãƒ»ã‚¬ãƒ©ã‚¹å¤©äº•
 *   Agent 3: ã‚¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ â”€ çµµç”»ãƒ»é¡è£…ãƒ»ãƒ—ãƒ¬ãƒ¼ãƒˆ
 *   Agent 4: ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ â”€ WASDãƒ»è¡çªåˆ¤å®š
 *   Agent 5: çµ±åˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ  â”€ ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ»ã‚´ãƒƒãƒ‰ãƒ¬ã‚¤ãƒ»å…¨ä½“
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  â‘  å®šæ•°ãƒ»å¯¸æ³•ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿  (å»ºç¯‰ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ / çµ±åˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const ROOM_W  = 26;    // éƒ¨å±‹ã®å¹…   X: -13 ï½ +13
const ROOM_D  = 42;    // éƒ¨å±‹ã®å¥¥è¡Œ Z: -21 ï½ +21
const ROOM_H  = 10;    // å¤©äº•ã®é«˜ã•
const WALL_T  = 0.28;  // å£ã®åšã¿

const EYE_H  = 1.72;   // ã‚«ãƒ¡ãƒ©é«˜ã•ï¼ˆç›®ç·šï¼‰
const SPEED  = 6.5;    // æ­©ãé€Ÿåº¦ (m/s)
const SPRINT = 12.0;   // èµ°ã‚Šé€Ÿåº¦ (m/s)

// ç§»å‹•å¯èƒ½é ˜åŸŸ (å£ã¨ã®ä½™ç™½)
const BND = {
  minX: -(ROOM_W / 2) + 0.65,
  maxX:  (ROOM_W / 2) - 0.65,
  minZ: -(ROOM_D / 2) + 0.65,
  maxZ:  (ROOM_D / 2) - 0.65,
};

// æŸ±é…ç½®
const COL_XS = [-7.5, 7.5];
const COL_ZS = [-13, -5, 3];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  â‘¡ ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ãƒ»ã‚·ãƒ¼ãƒ³ãƒ»ã‚«ãƒ¡ãƒ©åˆæœŸåŒ–  (çµ±åˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type    = THREE.PCFSoftShadowMap;
renderer.toneMapping       = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.18;
renderer.outputColorSpace  = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);          // ã‚¹ã‚«ã‚¤ãƒ–ãƒ«ãƒ¼èƒŒæ™¯
scene.fog = new THREE.FogExp2(0x9fd6f0, 0.010);        // è·é›¢ãƒ•ã‚©ã‚°

const camera = new THREE.PerspectiveCamera(
  70, innerWidth / innerHeight, 0.05, 250
);
camera.position.set(0, EYE_H, 18);

const controls = new PointerLockControls(camera, renderer.domElement);
scene.add(controls.getObject());


// â”€â”€â”€ PointerLock UI åˆ¶å¾¡ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const $overlay   = document.getElementById('overlay');
const $crosshair = document.getElementById('crosshair');
const $hint      = document.getElementById('hint');
const $loading   = document.getElementById('loading');
const $pauseMsg  = document.getElementById('pauseMsg');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ğŸ’³ Stripe æ±ºæ¸ˆè¨­å®š
//  â–¶ Stripeãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã§Â¥500ã®æ±ºæ¸ˆãƒªãƒ³ã‚¯ã‚’ä½œæˆã—ã€ä¸‹è¨˜ã«è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„
//  â–¶ æˆåŠŸURLã«ã¯å¿…ãš ?paid=true ã‚’æœ«å°¾ã«ä»˜ã‘ã¦ãã ã•ã„
//     ä¾‹: https://typhoon5406.github.io/virtual-museum/museum.html?paid=true
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const STRIPE_PAYMENT_LINK = ''; // â† ä¾‹: 'https://buy.stripe.com/XXXXXXXX'

// â”€â”€â”€ æ”¯æ‰•ã„æ¸ˆã¿ãƒã‚§ãƒƒã‚¯ï¼ˆURLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ â†’ sessionStorageï¼‰ â”€â”€â”€â”€â”€
{
  const _p = new URLSearchParams(location.search);
  if (_p.get('paid') === 'true') {
    sessionStorage.setItem('museum_paid', '1');
    history.replaceState(null, '', location.pathname); // URLã‚’ç¶ºéº—ã«
  }
}
const isPaid = sessionStorage.getItem('museum_paid') === '1';

// â”€â”€â”€ æ”¯æ‰•ã„æ¸ˆã¿ã®å ´åˆã¯UIã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (isPaid) {
  document.getElementById('serviceDesc').style.display = 'none';
  document.getElementById('paidMsg').style.display     = 'block';
  document.getElementById('startBtn').textContent      = 'å…¥ã€€ã€€å ´';
  document.getElementById('keyhint').style.display     = 'block';
}

// â”€â”€â”€ å…¥å ´ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('startBtn').addEventListener('click', () => {
  if (isPaid) {
    // æ”¯æ‰•ã„æ¸ˆã¿ â†’ ãã®ã¾ã¾å…¥å ´
    controls.lock();
  } else if (STRIPE_PAYMENT_LINK) {
    // æœªæ‰•ã„ â†’ Stripeæ±ºæ¸ˆãƒªãƒ³ã‚¯ã¸ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
    location.href = STRIPE_PAYMENT_LINK;
  } else {
    // æ±ºæ¸ˆãƒªãƒ³ã‚¯æœªè¨­å®š â†’ ç®¡ç†è€…å‘ã‘è­¦å‘Šï¼ˆå…¬é–‹å‰ã«è¨­å®šã—ã¦ãã ã•ã„ï¼‰
    alert(
      'ã€ç®¡ç†è€…ã¸ã€‘\nSTRIPE_PAYMENT_LINK ãŒæœªè¨­å®šã§ã™ã€‚\n' +
      'museum.html ã® STRIPE_PAYMENT_LINK å¤‰æ•°ã«\n' +
      'Stripeãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã§ä½œæˆã—ãŸæ±ºæ¸ˆãƒªãƒ³ã‚¯ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚'
    );
  }
});

controls.addEventListener('lock', () => {
  $overlay.classList.add('hidden');
  $crosshair.classList.add('show');
  $hint.classList.add('show');
  $pauseMsg.classList.remove('show');
});
controls.addEventListener('unlock', () => {
  $crosshair.classList.remove('show');
  $hint.classList.remove('show');
  $pauseMsg.classList.add('show');
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  â‘¢ ç…§æ˜ã‚·ã‚¹ãƒ†ãƒ   (ç…§æ˜ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function buildLighting() {

  // 3-A. ç’°å¢ƒå…‰ (æŸ”ã‚‰ã‹ã„æš–è‰²ãƒ™ãƒ¼ã‚¹)
  scene.add(new THREE.AmbientLight(0xfff2e0, 0.60));

  // 3-B. å¤ªé™½å…‰ DirectionalLight (å½±ä»˜ãã€ã‚¬ãƒ©ã‚¹å¤©äº•ã‹ã‚‰å·®ã—è¾¼ã‚€)
  const sun = new THREE.DirectionalLight(0xfffbf0, 2.6);
  sun.position.set(9, ROOM_H + 18, 8);
  sun.target.position.set(0, 0, -4);
  sun.castShadow = true;
  const sc = sun.shadow.camera;
  sc.left = -22; sc.right = 22;
  sc.top  =  26; sc.bottom = -26;
  sc.near = 1.0; sc.far   = 55;
  sun.shadow.mapSize.set(2048, 2048);
  sun.shadow.bias = -0.0003;
  sun.shadow.normalBias = 0.02;
  scene.add(sun, sun.target);

  // 3-C. å¤©ç©ºå…‰ HemisphereLight (ä¸Šç©ºã¨åœ°é¢ã®æ•£ä¹±å…‰)
  scene.add(new THREE.HemisphereLight(0x87ceeb, 0xd8c8a8, 0.48));

  // 3-D. è£œåŠ© PointLight (å®¤å†…ã®åå°„å…‰æ„Ÿ)
  const fill = new THREE.PointLight(0xfff5e0, 0.9, 30, 1.5);
  fill.position.set(0, ROOM_H - 1.5, -2);
  scene.add(fill);

  // 3-E. çµµç”»ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆ (4æšÃ—å„1ç¯)
  const spotDefs = [
    // [ç¯å°] åŒ—å£ å·¦
    { from: [-5.5, ROOM_H - 0.8, -17.5], at: [-5,   2.6, -(ROOM_D/2)] },
    // [å±±]   åŒ—å£ å³
    { from: [ 5.5, ROOM_H - 0.8, -17.5], at: [ 5,   2.6, -(ROOM_D/2)] },
    // [ãŠã°ã•ã‚“] è¥¿å£
    { from: [-9.5, ROOM_H - 0.8,  -7.0], at: [-(ROOM_W/2), 2.8,  -7]  },
    // [ä¸­å›½å¥³æ€§] æ±å£
    { from: [ 9.5, ROOM_H - 0.8,  -7.0], at: [ (ROOM_W/2), 2.8,  -7]  },
  ];
  spotDefs.forEach(({ from, at }) => {
    const spot = new THREE.SpotLight(0xfff8e8, 2.4);
    spot.position.set(...from);
    spot.angle    = Math.PI / 7.5;
    spot.penumbra = 0.48;
    spot.decay    = 1.3;
    spot.castShadow = true;
    spot.shadow.mapSize.set(512, 512);
    const tgt = new THREE.Object3D();
    tgt.position.set(...at);
    scene.add(tgt);
    spot.target = tgt;
    scene.add(spot);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  â‘£ å»ºç¯‰ã‚¸ã‚ªãƒ¡ãƒˆãƒª  (å»ºç¯‰ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function buildArchitecture() {

  // â”€â”€ ãƒãƒ†ãƒªã‚¢ãƒ«å®šç¾© â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const floorMat = new THREE.MeshStandardMaterial({
    color: 0xf2ede5, roughness: 0.10, metalness: 0.04,
  });
  const wallMat = new THREE.MeshStandardMaterial({
    color: 0xfaf8f4, roughness: 0.80, metalness: 0.0,
  });
  const columnMat = new THREE.MeshStandardMaterial({
    color: 0xf4f0eb, roughness: 0.28, metalness: 0.06,
  });
  const trimMat = new THREE.MeshStandardMaterial({
    color: 0xe8e2d8, roughness: 0.60, metalness: 0.0,
  });

  // â”€â”€ ãƒ˜ãƒ«ãƒ‘ãƒ¼ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function addBox(w, h, d, mat, x, y, z, cast = true, recv = true) {
    const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
    m.position.set(x, y, z);
    m.castShadow    = cast;
    m.receiveShadow = recv;
    scene.add(m);
    return m;
  }

  // â”€â”€ 4-A. åºŠ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  addBox(ROOM_W + WALL_T * 2, WALL_T, ROOM_D + WALL_T * 2,
    floorMat, 0, -WALL_T / 2, 0, false, true);

  // â”€â”€ 4-B. å››æ–¹ã®å£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //  åŒ—å£ï¼ˆå¥¥ï¼‰
  addBox(ROOM_W + WALL_T * 2, ROOM_H, WALL_T,
    wallMat, 0, ROOM_H / 2, -(ROOM_D / 2) - WALL_T / 2);
  //  å—å£ï¼ˆæ‰‹å‰ï¼‰
  addBox(ROOM_W + WALL_T * 2, ROOM_H, WALL_T,
    wallMat, 0, ROOM_H / 2,  (ROOM_D / 2) + WALL_T / 2);
  //  è¥¿å£
  addBox(WALL_T, ROOM_H, ROOM_D,
    wallMat, -(ROOM_W / 2) - WALL_T / 2, ROOM_H / 2, 0);
  //  æ±å£
  addBox(WALL_T, ROOM_H, ROOM_D,
    wallMat,  (ROOM_W / 2) + WALL_T / 2, ROOM_H / 2, 0);

  // â”€â”€ 4-C. å¹…æœ¨ï¼ˆåºŠã¾ã‚ã‚Šï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const baseH = 0.14, baseD = 0.04;
  addBox(ROOM_W, baseH, baseD, trimMat, 0, baseH / 2, -(ROOM_D / 2) + baseD / 2);
  addBox(ROOM_W, baseH, baseD, trimMat, 0, baseH / 2,  (ROOM_D / 2) - baseD / 2);
  addBox(baseD, baseH, ROOM_D, trimMat, -(ROOM_W / 2) + baseD / 2, baseH / 2, 0);
  addBox(baseD, baseH, ROOM_D, trimMat,  (ROOM_W / 2) - baseD / 2, baseH / 2, 0);

  // â”€â”€ 4-D. å¤©äº•ã‚³ãƒ¼ãƒ‹ã‚¹ï¼ˆå»»ã‚Šç¸ï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const cornH = 0.18, cornD = 0.10;
  addBox(ROOM_W, cornH, cornD, trimMat, 0, ROOM_H - cornH / 2, -(ROOM_D / 2) + cornD / 2, false, false);
  addBox(ROOM_W, cornH, cornD, trimMat, 0, ROOM_H - cornH / 2,  (ROOM_D / 2) - cornD / 2, false, false);
  addBox(cornD, cornH, ROOM_D, trimMat, -(ROOM_W / 2) + cornD / 2, ROOM_H - cornH / 2, 0, false, false);
  addBox(cornD, cornH, ROOM_D, trimMat,  (ROOM_W / 2) - cornD / 2, ROOM_H - cornH / 2, 0, false, false);

  // â”€â”€ 4-E. æŸ±ï¼ˆ12æœ¬ï¼šå·¦å³å„ Ã— 3è¡Œï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const colH   = ROOM_H - 0.36;
  const colGeo  = new THREE.CylinderGeometry(0.32, 0.36, colH, 20);
  const capGeo  = new THREE.BoxGeometry(0.90, 0.20, 0.90);
  const baseGeo = new THREE.BoxGeometry(0.90, 0.16, 0.90);

  COL_XS.forEach(cx => {
    COL_ZS.forEach(cz => {
      // æŸ±æœ¬ä½“
      const col = new THREE.Mesh(colGeo, columnMat);
      col.position.set(cx, colH / 2 + 0.16, cz);
      col.castShadow = col.receiveShadow = true;
      scene.add(col);
      // æŸ±é ­
      const cap = new THREE.Mesh(capGeo, columnMat);
      cap.position.set(cx, ROOM_H - 0.26, cz);
      cap.castShadow = cap.receiveShadow = true;
      scene.add(cap);
      // å°åº§
      const base = new THREE.Mesh(baseGeo, columnMat);
      base.position.set(cx, 0.08, cz);
      base.castShadow = base.receiveShadow = true;
      scene.add(base);
    });
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  â‘¤ ã‚¬ãƒ©ã‚¹å¤©äº• + å…‰ã®æŸ±ï¼ˆã‚´ãƒƒãƒ‰ãƒ¬ã‚¤ï¼‰  (ç…§æ˜ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const godRayMeshes = [];

function buildGlassCeiling() {

  // â”€â”€ 5-A. ã‚¬ãƒ©ã‚¹ãƒ‘ãƒãƒ«ï¼ˆ4åˆ— Ã— 5è¡Œï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const COLS = 4, ROWS = 5;
  const PW = ROOM_W / COLS;   // 6.5m
  const PD = ROOM_D / ROWS;   // 8.4m
  const GAP = 0.09;            // ãƒ•ãƒ¬ãƒ¼ãƒ å¹…

  const glassMat = new THREE.MeshStandardMaterial({
    color:       0xb0d8f8,
    transparent: true,
    opacity:     0.28,
    roughness:   0.0,
    metalness:   0.18,
    side:        THREE.DoubleSide,
    depthWrite:  false,
  });

  for (let c = 0; c < COLS; c++) {
    for (let r = 0; r < ROWS; r++) {
      const gx = -ROOM_W / 2 + PW * (c + 0.5);
      const gz = -ROOM_D / 2 + PD * (r + 0.5);
      const panel = new THREE.Mesh(
        new THREE.BoxGeometry(PW - GAP, 0.05, PD - GAP),
        glassMat
      );
      panel.position.set(gx, ROOM_H + 0.025, gz);
      panel.receiveShadow = true;
      scene.add(panel);
    }
  }

  // â”€â”€ 5-B. å¤©äº•ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆã‚¢ãƒ«ãƒŸæ ¼å­ï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const frameMat = new THREE.MeshStandardMaterial({
    color: 0x8fa0b0, roughness: 0.28, metalness: 0.72,
  });
  // æ¨ªæ¡Ÿ
  for (let r = 0; r <= ROWS; r++) {
    const fz = -ROOM_D / 2 + PD * r;
    const bar = new THREE.Mesh(
      new THREE.BoxGeometry(ROOM_W + WALL_T * 2, 0.12, GAP), frameMat
    );
    bar.position.set(0, ROOM_H, fz);
    bar.castShadow = bar.receiveShadow = true;
    scene.add(bar);
  }
  // ç¸¦æ¡Ÿ
  for (let c = 0; c <= COLS; c++) {
    const fx = -ROOM_W / 2 + PW * c;
    const bar = new THREE.Mesh(
      new THREE.BoxGeometry(GAP, 0.12, ROOM_D + WALL_T * 2), frameMat
    );
    bar.position.set(fx, ROOM_H, 0);
    bar.castShadow = bar.receiveShadow = true;
    scene.add(bar);
  }

  // â”€â”€ 5-C. å…‰ã®æŸ±ï¼ˆã‚´ãƒƒãƒ‰ãƒ¬ã‚¤ï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const rayMat = new THREE.MeshBasicMaterial({
    color:      0xfffce8,
    transparent: true,
    opacity:    0.058,
    depthWrite: false,
    blending:   THREE.AdditiveBlending,
    side:       THREE.FrontSide,
  });

  // å…‰æŸ±ã®é…ç½®ï¼ˆã‚¬ãƒ©ã‚¹ãƒ‘ãƒãƒ«ä¸­å¿ƒã®ç›´ä¸‹ï¼‰
  const rayPositions = [
    [-6.5, -16.0],  // åˆ—1è¡Œ1
    [ 0.0, -16.0],  // åˆ—2è¡Œ1
    [ 6.5, -16.0],  // åˆ—3è¡Œ1
    [-6.5,  -7.5],  // åˆ—1è¡Œ3
    [ 6.5,  -7.5],  // åˆ—3è¡Œ3
    [ 0.0,   1.0],  // ä¸­å¤®
  ];

  rayPositions.forEach(([rx, rz]) => {
    const mat = rayMat.clone();
    const ray = new THREE.Mesh(
      new THREE.CylinderGeometry(0.28, 0.72, ROOM_H * 0.97, 14, 1, true),
      mat
    );
    ray.position.set(rx, ROOM_H * 0.485, rz);
    ray.renderOrder = 2;
    scene.add(ray);
    godRayMeshes.push(ray);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  â‘¥ å¡µãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«  (çµ±åˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let dustGeo = null;
let dustVel = null;
let dustPhase = null;
const DUST_N = 1600;

function buildDust() {
  const pos   = new Float32Array(DUST_N * 3);
  dustVel     = new Float32Array(DUST_N * 3);
  dustPhase   = new Float32Array(DUST_N);

  const HW = ROOM_W / 2 * 0.88;
  const HD = ROOM_D / 2 * 0.88;

  for (let i = 0; i < DUST_N; i++) {
    // å…‰æŸ±ä»˜è¿‘ 60%ã€ãã‚Œä»¥å¤– 40%
    const nearRay = Math.random() < 0.60;
    const rx = nearRay ? ([-6.5, 0, 6.5][Math.floor(Math.random() * 3)]) : 0;
    const rz = nearRay ? ([-16, -7.5, 1][Math.floor(Math.random() * 3)]) : 0;
    const spread = nearRay ? 1.8 : HW;

    pos[i*3]   = rx + (Math.random() - 0.5) * spread * 2;
    pos[i*3+1] = Math.random() * ROOM_H * 0.88 + 0.25;
    pos[i*3+2] = rz + (Math.random() - 0.5) * (nearRay ? spread * 2 : HD * 2);

    dustVel[i*3]   = (Math.random() - 0.5) * 0.0028;
    dustVel[i*3+1] = (Math.random() - 0.5) * 0.0014;
    dustVel[i*3+2] = (Math.random() - 0.5) * 0.0028;
    dustPhase[i]   = Math.random() * Math.PI * 2;
  }

  dustGeo = new THREE.BufferGeometry();
  dustGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));

  const dustMat = new THREE.PointsMaterial({
    color:           0xfff8e0,
    size:            0.032,
    sizeAttenuation: true,
    transparent:     true,
    opacity:         0.52,
    depthWrite:      false,
    blending:        THREE.AdditiveBlending,
  });

  scene.add(new THREE.Points(dustGeo, dustMat));
}

function updateDust(t) {
  if (!dustGeo) return;
  const pos = dustGeo.attributes.position.array;
  const HW = ROOM_W / 2 - 0.5;
  const HD = ROOM_D / 2 - 0.5;

  for (let i = 0; i < DUST_N; i++) {
    const i3 = i * 3;
    const sway = Math.sin(t * 0.22 + dustPhase[i]) * 0.0012;
    pos[i3]   += dustVel[i3]   + sway;
    pos[i3+1] += dustVel[i3+1] + Math.sin(t * 0.16 + dustPhase[i] * 1.3) * 0.0008;
    pos[i3+2] += dustVel[i3+2] + sway * 0.7;

    if (pos[i3]   >  HW)          pos[i3]   = -HW;
    if (pos[i3]   < -HW)          pos[i3]   =  HW;
    if (pos[i3+1] >  ROOM_H * 0.9) pos[i3+1] = 0.2;
    if (pos[i3+1] <  0.1)          pos[i3+1] = ROOM_H * 0.85;
    if (pos[i3+2] >  HD)           pos[i3+2] = -HD;
    if (pos[i3+2] < -HD)           pos[i3+2] =  HD;
  }
  dustGeo.attributes.position.needsUpdate = true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  â‘¦ çµµç”»å±•ç¤º  (ã‚¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ)
//
//  é…ç½®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼š
//   åŒ—å£ (Z=-21):  [ç¯å°] X=-5   [å±±]   X=+5    â† é¢¨æ™¯æ¨ªé•· Ã— 2
//   è¥¿å£ (X=-13):  [ãŠã°ã•ã‚“] Z=-7               â† äººç‰©ç¸¦é•·
//   æ±å£ (X=+13):  [ä¸­å›½å¥³æ€§] Z=-7               â† äººç‰©ç¸¦é•·
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function buildPaintings() {
  const texLoader = new THREE.TextureLoader();
  let loadedCount = 0;
  const totalPaintings = 4;

  // çµµç”»å®šç¾©ãƒªã‚¹ãƒˆ
  const PAINTINGS = [
    {
      // â”€â”€ é¢¨æ™¯ï¼šæµ·è¾ºã®ç¯å°ï¼ˆåŒ—å£ å·¦ï¼‰
      file:  'painting_lighthouse.png',
      posX:  -5.5,
      posY:   3.0,
      posZ:  -(ROOM_D / 2) + 0.06,
      rotY:   0,           // åŒ—å£ï¼š+Zæ–¹å‘ã¸å‘ãï¼ˆå…¥å£å´ã‚’å‘ãï¼‰
      dispH:  3.2,         // è¡¨ç¤ºé«˜ã• (m) â”€ aspect ratio ã‹ã‚‰å¹…ã‚’è‡ªå‹•è¨ˆç®—
    },
    {
      // â”€â”€ é¢¨æ™¯ï¼šé™ºã—ã„å±±ï¼ˆåŒ—å£ å³ï¼‰
      file:  'painting_mountain.png',
      posX:   5.5,
      posY:   3.0,
      posZ:  -(ROOM_D / 2) + 0.06,
      rotY:   0,
      dispH:  3.2,
    },
    {
      // â”€â”€ äººç‰©ï¼šæµ·å¤–ã®ãŠã°ã•ã‚“ï¼ˆè¥¿å£ï¼‰
      file:  'painting_lady.png',
      posX:  -(ROOM_W / 2) + 0.06,
      posY:   3.1,
      posZ:  -7.0,
      rotY:   Math.PI / 2,   // è¥¿å£ï¼š+Xæ–¹å‘ã¸å‘ãï¼ˆä¸­å¤®ã‚’å‘ãï¼‰
      dispH:  3.8,
    },
    {
      // â”€â”€ äººç‰©ï¼šä¸­å›½ã®å¥³æ€§ï¼ˆæ±å£ï¼‰
      file:  'painting_chinese_woman.png',
      posX:   (ROOM_W / 2) - 0.06,
      posY:   3.1,
      posZ:  -7.0,
      rotY:  -Math.PI / 2,   // æ±å£ï¼š-Xæ–¹å‘ã¸å‘ãï¼ˆä¸­å¤®ã‚’å‘ãï¼‰
      dispH:  3.8,
    },
  ];

  // èª¬æ˜ãƒ—ãƒ¬ãƒ¼ãƒˆç”¨ãƒãƒ†ãƒªã‚¢ãƒ«
  const plateMat = new THREE.MeshStandardMaterial({
    color: 0xece8e0, roughness: 0.70, metalness: 0.0,
  });

  PAINTINGS.forEach((p) => {
    texLoader.load(
      p.file,

      // â”€â”€ onLoad â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      (tex) => {
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.minFilter  = THREE.LinearMipmapLinearFilter;
        tex.magFilter  = THREE.LinearFilter;
        tex.anisotropy = Math.min(renderer.capabilities.getMaxAnisotropy(), 16);

        // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ç¸¦æ¨ªæ¯”ã‹ã‚‰å®Ÿéš›ã®ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
        const aspect = tex.image.width / tex.image.height;
        const pH = p.dispH;
        const pW = pH * aspect;

        const group = new THREE.Group();

        // â”€ çµµç”»æœ¬ä½“ï¼ˆç”»åƒã«ãƒ•ãƒ¬ãƒ¼ãƒ ãŒå†…åŒ…ã•ã‚Œã¦ã„ã‚‹ã®ã§ãã®ã¾ã¾è¡¨ç¤ºï¼‰
        const paintMesh = new THREE.Mesh(
          new THREE.PlaneGeometry(pW, pH),
          new THREE.MeshStandardMaterial({
            map:       tex,
            roughness: 0.84,
            metalness: 0.0,
          })
        );
        paintMesh.castShadow    = true;
        paintMesh.receiveShadow = true;
        group.add(paintMesh);

        // â”€ å£é¢å½±æ¿ï¼ˆçµµç”»å¾Œã‚ã®ã‚ãšã‹ãªå½±ã§ç«‹ä½“æ„Ÿã‚’æ¼”å‡ºï¼‰
        const shadowPad = new THREE.Mesh(
          new THREE.PlaneGeometry(pW + 0.14, pH + 0.14),
          new THREE.MeshStandardMaterial({
            color:       0x050505,
            transparent: true,
            opacity:     0.22,
            roughness:   1.0,
            metalness:   0.0,
          })
        );
        shadowPad.position.z = -0.012;
        group.add(shadowPad);

        // â”€ èª¬æ˜ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆçµµç”»ä¸‹ï¼‰
        const plateW  = Math.min(pW * 0.46, 1.1);
        const plateH  = 0.14;
        const plateMesh = new THREE.Mesh(
          new THREE.BoxGeometry(plateW, plateH, 0.022),
          plateMat
        );
        plateMesh.position.set(0, -(pH / 2) - 0.11, 0.01);
        plateMesh.castShadow = true;
        group.add(plateMesh);

        // â”€ ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã«é…ç½®
        group.position.set(p.posX, p.posY, p.posZ);
        group.rotation.y = p.rotY;
        scene.add(group);

        loadedCount++;
        if (loadedCount >= totalPaintings) {
          $loading.style.display = 'none';
        }
      },

      // â”€â”€ onProgressï¼ˆæœªä½¿ç”¨ï¼‰
      undefined,

      // â”€â”€ onError
      (err) => {
        console.warn(`[ã‚¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ] çµµç”»ãƒ­ãƒ¼ãƒ‰å¤±æ•—: ${p.file}`, err);
        loadedCount++;
        if (loadedCount >= totalPaintings) {
          $loading.style.display = 'none';
        }
      }
    );
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  â‘§ ã‚­ãƒ¼å…¥åŠ› & ç§»å‹• + è¡çªåˆ¤å®š  (ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const keyState = {};
window.addEventListener('keydown', e => { keyState[e.code] = true; });
window.addEventListener('keyup',   e => { keyState[e.code] = false; });

const _moveDir = new THREE.Vector3();

function updateMovement(delta) {
  if (!controls.isLocked) return;

  // å…¥åŠ›ãƒ™ã‚¯ãƒˆãƒ«
  _moveDir.set(0, 0, 0);
  if (keyState['KeyW'] || keyState['ArrowUp'])    _moveDir.z -= 1;
  if (keyState['KeyS'] || keyState['ArrowDown'])  _moveDir.z += 1;
  if (keyState['KeyA'] || keyState['ArrowLeft'])  _moveDir.x -= 1;
  if (keyState['KeyD'] || keyState['ArrowRight']) _moveDir.x += 1;

  if (_moveDir.lengthSq() > 0) {
    _moveDir.normalize();
    const spd = (keyState['ShiftLeft'] || keyState['ShiftRight']) ? SPRINT : SPEED;
    controls.moveRight(   _moveDir.x * spd * delta);
    controls.moveForward(-_moveDir.z * spd * delta);
  }

  const pos = controls.getObject().position;

  // â”€â”€ å£å¢ƒç•Œã‚¯ãƒ©ãƒ³ãƒ— â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  pos.x = THREE.MathUtils.clamp(pos.x, BND.minX, BND.maxX);
  pos.z = THREE.MathUtils.clamp(pos.z, BND.minZ, BND.maxZ);
  pos.y = EYE_H;    // Yå›ºå®šï¼ˆã‚¸ãƒ£ãƒ³ãƒ—ãªã—ï¼‰

  // â”€â”€ æŸ±ã¨ã®å††å½¢è¡çªåˆ¤å®š â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const COL_R = 0.72;   // æŸ±åŠå¾„ + ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åŠå¾„
  COL_XS.forEach(cx => {
    COL_ZS.forEach(cz => {
      const dx = pos.x - cx;
      const dz = pos.z - cz;
      const d2 = dx * dx + dz * dz;
      if (d2 < COL_R * COL_R) {
        const d = Math.sqrt(d2) || 0.001;
        pos.x = cx + (dx / d) * COL_R;
        pos.z = cz + (dz / d) * COL_R;
      }
    });
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  â‘¨ ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  â‘© ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—  (çµ±åˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  const time  = clock.getElapsedTime();

  // ç§»å‹• & è¡çª
  updateMovement(delta);

  // å¡µãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
  updateDust(time);

  // ã‚´ãƒƒãƒ‰ãƒ¬ã‚¤è¼åº¦ãƒ‘ãƒ«ã‚¹
  godRayMeshes.forEach((ray, i) => {
    ray.material.opacity = 0.042 + 0.020 * Math.sin(time * 0.48 + i * 1.15);
  });

  renderer.render(scene, camera);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  â‘ª åˆæœŸåŒ–  â”€  å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’é †åºé€šã‚Šã«å‘¼ã³å‡ºã™
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(function init() {
  buildLighting();       // [ç…§æ˜ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ]
  buildArchitecture();   // [å»ºç¯‰ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ]
  buildGlassCeiling();   // [ç…§æ˜ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ]
  buildDust();           // [çµ±åˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ]
  buildPaintings();      // [ã‚¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ]
  animate();             // [ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ + çµ±åˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ]
})();

</script>
</body>
</html>
